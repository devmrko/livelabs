#!/usr/bin/env python3
"""
Reasoning + Acting Example using Oracle GenAI
Demonstrates structured reasoning, action planning, and execution
"""

import logging
import json
import os
from typing import List, Dict, Optional, Tuple
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

# Import your OCILLMProvider
import oci
from oci.generative_ai_inference import GenerativeAiInferenceClient
from oci.generative_ai_inference import models as genai_models

# Set up logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class OCILLMProvider:
    """Simplified OCI LLM provider for the reasoning + acting example"""
    
    def __init__(self, model_id: str = "xai.grok-4"):
        self.model_id = model_id
        self.compartment_id = os.getenv('OCI_COMPARTMENT_ID')
        self.endpoint = os.getenv('OCI_GENAI_ENDPOINT')
        self.config_file_path = os.path.expanduser(os.getenv('OCI_CONFIG_PATH', '~/.oci/config'))
        self.config_profile = os.getenv('OCI_CONFIG_PROFILE', 'DEFAULT')
        
        self.client = self._initialize_client()
    
    def _initialize_client(self):
        """Initialize OCI Generative AI client"""
        try:
            oci_config = oci.config.from_file(
                file_location=self.config_file_path,
                profile_name=self.config_profile
            )
            
            if not self.compartment_id and oci_config.get("tenancy"):
                self.compartment_id = oci_config.get("tenancy")
                logger.info(f"Using tenancy ID {self.compartment_id} as compartment ID")
            
            client = GenerativeAiInferenceClient(
                config=oci_config,
                service_endpoint=self.endpoint,
                retry_strategy=oci.retry.NoneRetryStrategy(),
                timeout=(10, 240)
            )
            
            logger.info(f"OCI GenAI client initialized with model: {self.model_id}")
            return client
            
        except Exception as e:
            logger.error(f"Failed to initialize OCI client: {e}")
            return None
    
    def generate_response(self, prompt: str, temperature: float = 0.7, max_tokens: int = 1000) -> Optional[str]:
        """Generate response from OCI GenAI"""
        if not self.client:
            logger.error("OCI client not initialized")
            return None
        
        try:
            content = genai_models.TextContent(text=prompt, type="TEXT")
            message = genai_models.Message(role="USER", content=[content])
            
            chat_request = genai_models.GenericChatRequest(
                api_format=genai_models.BaseChatRequest.API_FORMAT_GENERIC,
                messages=[message],
                max_tokens=max_tokens,
                temperature=temperature
            )
            
            chat_details = genai_models.ChatDetails(
                serving_mode=genai_models.OnDemandServingMode(model_id=self.model_id),
                chat_request=chat_request,
                compartment_id=self.compartment_id
            )
            
            response = self.client.chat(chat_details)
            return response.data.chat_response.choices[0].message.content[0].text.strip()
            
        except Exception as e:
            logger.error(f"Error generating response: {e}")
            return None

class MockTools:
    """Mock tools that the AI can use"""
    
    def __init__(self):
        # Mock database data
        self.mock_db_data = {
            "workshops": [
                {
                    "id": "648",
                    "title": "Oracle Cloud Infrastructure Core Services ÏãúÏûëÌïòÍ∏∞",
                    "description": "OCIÏùò Í∏∞Î≥∏ ÏÑúÎπÑÏä§ ÌÉêÏÉâ: ÎÑ§Ìä∏ÏõåÌÇπ, Ïª¥Ìì®ÌåÖ, Ïä§ÌÜ†Î¶¨ÏßÄ Îì±",
                    "duration": "2ÏãúÍ∞Ñ 30Î∂Ñ",
                    "views": 223466,
                    "last_updated": "2024-01-15",
                    "category": "OCI Basics"
                },
                {
                    "id": "1070",
                    "title": "Oracle Database 23c ÏÉàÎ°úÏö¥ Í∏∞Îä•",
                    "description": "Oracle Database 23cÏùò ÏµúÏã† Í∏∞Îä•Îì§ ÏÜåÍ∞ú",
                    "duration": "1ÏãúÍ∞Ñ 45Î∂Ñ",
                    "views": 156789,
                    "last_updated": "2023-12-20",
                    "category": "Database"
                },
                {
                    "id": "892",
                    "title": "Oracle Cloud Security Î™®Î≤î ÏÇ¨Î°Ä",
                    "description": "OCIÏóêÏÑú Î≥¥ÏïàÏùÑ Í∞ïÌôîÌïòÎäî Î∞©Î≤ïÍ≥º Î™®Î≤î ÏÇ¨Î°Ä",
                    "duration": "3ÏãúÍ∞Ñ",
                    "views": 98765,
                    "last_updated": "2024-02-10",
                    "category": "Security"
                },
                {
                    "id": "445",
                    "title": "Oracle 12c Database Í¥ÄÎ¶¨",
                    "description": "Oracle 12c Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Í¥ÄÎ¶¨ Î∞è Ïú†ÏßÄÎ≥¥Ïàò",
                    "duration": "2ÏãúÍ∞Ñ",
                    "views": 45678,
                    "last_updated": "2020-05-15",
                    "category": "Database"
                }
            ]
        }
        
        # Mock vector embeddings (simplified)
        self.mock_embeddings = {
            "cloud_computing": ["648", "892"],
            "database": ["1070", "445"],
            "security": ["892"],
            "oci": ["648", "892"],
            "oracle_12c": ["445"],
            "oracle_23c": ["1070"]
        }
    
    def search_database(self, query: str) -> dict:
        """Mock database search using SQL-like queries"""
        print(f"üîç Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Í≤ÄÏÉâ Ïã§Ìñâ: {query}")
        
        results = []
        query_lower = query.lower()
        
        for workshop in self.mock_db_data["workshops"]:
            # Simple keyword matching
            if any(keyword in workshop["title"].lower() or keyword in workshop["description"].lower() 
                   for keyword in query_lower.split()):
                results.append(workshop)
        
        return {
            "query": query,
            "results": results,
            "count": len(results),
            "status": "SUCCESS"
        }
    
    def vector_search(self, query: str, top_k: int = 5) -> dict:
        """Mock vector search using semantic similarity"""
        print(f"üîç Î≤°ÌÑ∞ Í≤ÄÏÉâ Ïã§Ìñâ: {query} (ÏÉÅÏúÑ {top_k}Í∞ú)")
        
        query_lower = query.lower()
        results = []
        
        # Simple semantic matching
        for topic, workshop_ids in self.mock_embeddings.items():
            if any(word in topic for word in query_lower.split()):
                for workshop_id in workshop_ids:
                    workshop = next((w for w in self.mock_db_data["workshops"] if w["id"] == workshop_id), None)
                    if workshop:
                        results.append({
                            **workshop,
                            "similarity_score": 0.85 + (len(results) * 0.05)  # Mock similarity score
                        })
        
        # Sort by similarity score and limit results
        results.sort(key=lambda x: x["similarity_score"], reverse=True)
        results = results[:top_k]
        
        return {
            "query": query,
            "results": results,
            "count": len(results),
            "top_k": top_k,
            "status": "SUCCESS"
        }

class ReasoningActor:
    """Reasoning + Acting agent using Oracle GenAI with tools"""
    
    def __init__(self):
        self.llm = OCILLMProvider()
        self.tools = MockTools()
        self.memory = []
    
    def _fix_json_string(self, json_str: str) -> str:
        """Fix common JSON parsing issues"""
        # Remove trailing commas before closing braces/brackets
        import re
        json_str = re.sub(r',(\s*[}\]])', r'\1', json_str)
        
        # Fix unclosed quotes by finding the last complete object
        brace_count = 0
        bracket_count = 0
        in_string = False
        escape_next = False
        
        for i, char in enumerate(json_str):
            if escape_next:
                escape_next = False
                continue
                
            if char == '\\':
                escape_next = True
                continue
                
            if char == '"' and not escape_next:
                in_string = not in_string
                continue
                
            if not in_string:
                if char == '{':
                    brace_count += 1
                elif char == '}':
                    brace_count -= 1
                elif char == '[':
                    bracket_count += 1
                elif char == ']':
                    bracket_count -= 1
                
                # If we have unbalanced braces/brackets, truncate
                if brace_count < 0 or bracket_count < 0:
                    json_str = json_str[:i]
                    break
        
        # Close any unclosed structures
        while bracket_count > 0:
            json_str += ']'
            bracket_count -= 1
        while brace_count > 0:
            json_str += '}'
            brace_count -= 1
            
        return json_str
    
    def _extract_partial_plan(self, response: str) -> Dict:
        """Extract partial plan information from failed JSON response"""
        try:
            # Try to extract reasoning
            reasoning_start = response.find('"reasoning":')
            if reasoning_start != -1:
                reasoning_start = response.find('"', reasoning_start + 11) + 1
                reasoning_end = response.find('"', reasoning_start)
                if reasoning_end != -1:
                    reasoning = response[reasoning_start:reasoning_end]
                else:
                    reasoning = "Î∂ÄÎ∂ÑÏ†Å Ï∂îÎ°† Ï∂îÏ∂úÎê®"
            else:
                reasoning = "Ï∂îÎ°†ÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏùå"
            
            # Try to extract plan steps
            plan_steps = []
            step_pattern = r'"step":\s*(\d+).*?"action":\s*"([^"]*)"'
            import re
            matches = re.findall(step_pattern, response, re.DOTALL)
            
            for i, (step_num, action) in enumerate(matches[:3]):  # Limit to 3 steps
                plan_steps.append({
                    "step": int(step_num),
                    "action": action.strip(),
                    "reason": f"Î∂ÄÎ∂ÑÏ†Å ÏùëÎãµÏóêÏÑú Ï∂îÏ∂úÎê®",
                    "expected_outcome": "Í≤∞Ï†ï ÏòàÏ†ï"
                })
            
            if not plan_steps:
                plan_steps = [{
                    "step": 1,
                    "action": "ÏõåÌÅ¨ÏÉµ Îç∞Ïù¥ÌÑ∞ Î∂ÑÏÑù",
                    "reason": "Î∂ÄÎ∂ÑÏ†Å ÏùëÎãµÏóêÏÑú Ï∂îÏ∂úÎê®",
                    "expected_outcome": "Îç∞Ïù¥ÌÑ∞ Î∂ÑÏÑù Í≤∞Í≥º"
                }]
            
            return {
                "reasoning": reasoning,
                "plan": plan_steps,
                "risks": ["Î∂ÄÎ∂ÑÏ†Å ÏùëÎãµ - ÏùºÎ∂Ä Ï†ïÎ≥¥Í∞Ä ÎàÑÎùΩÎê† Ïàò ÏûàÏùå"],
                "success_criteria": ["ÏÇ¨Ïö© Í∞ÄÎä•Ìïú Îç∞Ïù¥ÌÑ∞Ïùò ÏôÑÏ†ÑÌïú Î∂ÑÏÑù"]
            }
            
        except Exception as e:
            logger.error(f"Failed to extract partial plan: {e}")
            return None
    
    def _create_default_reflection(self) -> Dict:
        """Create a default reflection when parsing fails"""
        return {
            "success_rate": "Ïïå Ïàò ÏóÜÏùå",
            "key_insights": ["ÏùºÎ∂Ä Îã®Í≥ÑÍ∞Ä ÏÑ±Í≥µÏ†ÅÏúºÎ°ú ÏôÑÎ£åÎê®", "JSON ÌååÏã± Î¨∏Ï†ú Î∞úÏÉù"],
            "improvements": ["Ïò§Î•ò Ï≤òÎ¶¨ Í∞úÏÑ†", "ÏùëÎãµ Í≤ÄÏ¶ù Ï∂îÍ∞Ä"],
            "lessons_learned": ["Oracle GenAI ÏùëÎãµÏù¥ ÏùºÍ¥ÄÏÑ±Ïù¥ ÏóÜÏùÑ Ïàò ÏûàÏùå", "Îçî ÎÇòÏùÄ ÎåÄÏ≤¥ Î©îÏª§ÎãàÏ¶ò ÌïÑÏöî"],
            "recommendations": ["Îã§Î•∏ ÌîÑÎ°¨ÌîÑÌä∏Î°ú ÌÖåÏä§Ìä∏", "Ïû¨ÏãúÎèÑ Î°úÏßÅ Íµ¨ÌòÑ"]
        }
    
    def _create_default_execution_result(self, action: str, error_message: str, tools_used: list = None, tool_results: dict = None) -> Dict:
        """Create a default execution result when parsing fails"""
        result = {
            "action_executed": action,
            "result": f"ÏûëÏóÖ ÏãúÎèÑÌñàÏßÄÎßå Ïã§Ìå®: {error_message}",
            "status": "FAILED",
            "data": {},
            "next_steps": ["Îã§Ïùå Îã®Í≥Ñ Í≥ÑÏÜç", "ÏàòÎèô Í≤ÄÏ¶ù ÌïÑÏöî"],
            "notes": f"Îã§Ïùå Ïù¥Ïú†Î°ú Í∏∞Î≥∏ Í≤∞Í≥º ÏÉùÏÑ±Îê®: {error_message}"
        }
        
        if tools_used:
            result["tools_used"] = tools_used
        if tool_results:
            result["tool_results"] = tool_results
            
        return result
    
    def _extract_partial_execution_result(self, response: str, action: str) -> Dict:
        """Extract partial execution result from failed JSON response"""
        try:
            # Try to extract action_executed
            action_executed = action
            
            # Try to extract result
            result_start = response.find('"result":')
            if result_start != -1:
                result_start = response.find('"', result_start + 9) + 1
                result_end = response.find('"', result_start)
                if result_end != -1:
                    result = response[result_start:result_end]
                else:
                    result = "Î∂ÄÎ∂ÑÏ†Å Ïã§Ìñâ ÏôÑÎ£å"
            else:
                result = "ÏûëÏóÖ ÏãúÎèÑÌñàÏßÄÎßå ÏùëÎãµ ÌååÏã± Ïã§Ìå®"
            
            # Try to extract status
            status = "PARTIAL"
            if '"status":' in response:
                status_match = response.find('"status":')
                if status_match != -1:
                    status_start = response.find('"', status_match + 9) + 1
                    status_end = response.find('"', status_start)
                    if status_end != -1:
                        status = response[status_start:status_end]
            
            # Try to extract notes
            notes_start = response.find('"notes":')
            if notes_start != -1:
                notes_start = response.find('"', notes_start + 8) + 1
                notes_end = response.find('"', notes_start)
                if notes_end != -1:
                    notes = response[notes_start:notes_end]
                else:
                    notes = "Î∂ÄÎ∂ÑÏ†Å ÏùëÎãµ Ï∂îÏ∂úÎê®"
            else:
                notes = "ÏùëÎãµ ÌååÏã± Ïã§Ìå®ÌñàÏßÄÎßå ÏûëÏóÖÏùÄ ÏãúÎèÑÎê®"
            
            return {
                "action_executed": action_executed,
                "result": result,
                "status": status,
                "data": {},
                "next_steps": ["Îã§Ïùå Îã®Í≥Ñ Í≥ÑÏÜç", "Í≤∞Í≥º ÏàòÎèô ÌôïÏù∏"],
                "notes": notes
            }
            
        except Exception as e:
            logger.error(f"Failed to extract partial execution result: {e}")
            return None
    
    def _extract_search_query(self, action: str) -> str:
        """Extract search query from action description"""
        # Simple keyword extraction
        keywords = ['Oracle', 'Database', 'Cloud', 'Security', 'OCI', 'ÏõåÌÅ¨ÏÉµ', 'Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§', 'ÌÅ¥ÎùºÏö∞Îìú', 'Î≥¥Ïïà']
        
        for keyword in keywords:
            if keyword.lower() in action.lower():
                return keyword
        
        # Default fallback
        return "Oracle"
    
    def reason_and_plan(self, task: str, context: str = "") -> Dict:
        """Use LLM to reason about the task and create an action plan"""
        
        reasoning_prompt = f"""
ÎãπÏã†ÏùÄ ÏßÄÎä•Ï†ÅÏù∏ Ï∂îÎ°† ÏóêÏù¥Ï†ÑÌä∏ÏûÖÎãàÎã§. Ï£ºÏñ¥ÏßÑ ÏûëÏóÖÏùÑ Î∂ÑÏÑùÌïòÍ≥† Íµ¨Ï°∞ÌôîÎêú Ïã§Ìñâ Í≥ÑÌöçÏùÑ ÏàòÎ¶ΩÌïòÏÑ∏Ïöî.

ÏûëÏóÖ: {task}
Îß•ÎùΩ: {context}

Ï§ëÏöî: Í∞ÑÍ≤∞ÌïòÍ≥† Íµ¨Ï°∞ÌôîÎêú JSON ÏùëÎãµÏùÑ Ï†úÍ≥µÌïòÏÑ∏Ïöî. ÏûëÏóÖ ÏÑ§Î™ÖÏùÄ Í∞ÑÎã®ÌïòÏßÄÎßå Î™ÖÌôïÌïòÍ≤å ÏûëÏÑ±ÌïòÏÑ∏Ïöî.

Îã§Ïùå JSON ÌòïÏãùÏúºÎ°ú ÏùëÎãµÌï¥Ï£ºÏÑ∏Ïöî:
{{
    "reasoning": "ÏàòÌñâÌï¥Ïïº Ìï† ÏûëÏóÖÏóê ÎåÄÌïú Í∞ÑÎã®Ìïú Îã®Í≥ÑÎ≥Ñ Ï∂îÎ°†",
    "plan": [
        {{
            "step": 1,
            "action": "ÏàòÌñâÌï† ÏûëÏóÖÏùò Í∞ÑÎã®Ìïú ÏÑ§Î™Ö",
            "reason": "Ïù¥ ÏûëÏóÖÏù¥ ÌïÑÏöîÌïú Ïù¥Ïú†",
            "expected_outcome": "ÏòàÏÉÅ Í≤∞Í≥º"
        }}
    ],
    "risks": ["Ï£ºÏöî Ïû†Ïû¨Ï†Å Î¨∏Ï†úÏ†êÎì§"],
    "success_criteria": ["ÏÑ±Í≥µÏùÑ Ï∏°Ï†ïÌïòÎäî Î∞©Î≤ï"]
}}

ÏùëÎãµÏùÑ Í∞ÑÍ≤∞ÌïòÍ≤å Ïú†ÏßÄÌïòÍ≥† Ïú†Ìö®Ìïú JSON ÌòïÏãùÏùÑ Î≥¥Ïû•ÌïòÏÑ∏Ïöî.
"""
        
        response = self.llm.generate_response(reasoning_prompt, temperature=0.3)
        
        if response:
            try:
                # Try to extract JSON from response
                if "```json" in response:
                    json_start = response.find("```json") + 7
                    json_end = response.find("```", json_start)
                    json_str = response[json_start:json_end].strip()
                else:
                    # Look for JSON-like structure
                    start = response.find("{")
                    end = response.rfind("}") + 1
                    json_str = response[start:end]
                
                # Try to fix common JSON issues
                json_str = self._fix_json_string(json_str)
                
                plan = json.loads(json_str)
                logger.info("Successfully generated reasoning and plan")
                return plan
                
            except json.JSONDecodeError as e:
                logger.error(f"Failed to parse JSON response: {e}")
                logger.info(f"Raw response: {response}")
                
                # Try to extract partial information from the response
                partial_plan = self._extract_partial_plan(response)
                if partial_plan:
                    return partial_plan
                
                return {
                    "reasoning": "Failed to parse structured response",
                    "plan": [{"step": 1, "action": "Manual intervention required", "reason": "LLM response parsing failed"}],
                    "risks": ["Response parsing error"],
                    "success_criteria": ["Manual verification needed"]
                }
        
        return None
    
    def execute_action(self, action: str, context: Dict = None) -> Dict:
        """Execute a specific action and return results"""
        
        # Check if action requires tool usage
        tools_used = []
        tool_results = {}
        
        # Simple tool detection based on action content
        action_lower = action.lower()
        
        if any(keyword in action_lower for keyword in ['database', 'db', 'Í≤ÄÏÉâ', 'Ï°∞Ìöå', 'Îç∞Ïù¥ÌÑ∞']):
            # Use database search
            search_query = self._extract_search_query(action)
            if search_query:
                tools_used.append("search_database")
                tool_results["database_search"] = self.tools.search_database(search_query)
        
        if any(keyword in action_lower for keyword in ['vector', 'Î≤°ÌÑ∞', 'Ïú†ÏÇ¨', 'ÏùòÎØ∏', 'semantic']):
            # Use vector search
            search_query = self._extract_search_query(action)
            if search_query:
                tools_used.append("vector_search")
                tool_results["vector_search"] = self.tools.vector_search(search_query, top_k=3)
        
        # If no specific tools detected, try both for general queries
        if not tools_used and any(keyword in action_lower for keyword in ['ÏõåÌÅ¨ÏÉµ', 'workshop', 'Î∂ÑÏÑù', 'Ï∞æÍ∏∞']):
            search_query = self._extract_search_query(action) or "Oracle"
            tools_used.append("search_database")
            tool_results["database_search"] = self.tools.search_database(search_query)
        
        execution_prompt = f"""
ÎãπÏã†ÏùÄ ÏûëÏóÖ Ïã§Ìñâ ÏóêÏù¥Ï†ÑÌä∏ÏûÖÎãàÎã§. Îã§Ïùå ÏûëÏóÖÏùÑ Ïã§ÌñâÌïòÍ≥† Í≤∞Í≥ºÎ•º Ï†úÍ≥µÌïòÏÑ∏Ïöî.

ÏûëÏóÖ: {action}
Îß•ÎùΩ: {json.dumps(context) if context else "Ï∂îÍ∞Ä Îß•ÎùΩ ÏóÜÏùå"}

ÏÇ¨Ïö© Í∞ÄÎä•Ìïú ÎèÑÍµ¨:
1. search_database(query): Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ÏóêÏÑú ÏõåÌÅ¨ÏÉµ Ï†ïÎ≥¥ Í≤ÄÏÉâ
2. vector_search(query, top_k): ÏùòÎØ∏Ï†Å Ïú†ÏÇ¨ÏÑ±ÏùÑ Í∏∞Î∞òÏúºÎ°ú ÏõåÌÅ¨ÏÉµ Í≤ÄÏÉâ

ÎèÑÍµ¨ ÏÇ¨Ïö© ÏòàÏãú:
- Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Í≤ÄÏÉâÏù¥ ÌïÑÏöîÌïú Í≤ΩÏö∞: "search_database('Oracle Database')"
- ÏùòÎØ∏Ï†Å Í≤ÄÏÉâÏù¥ ÌïÑÏöîÌïú Í≤ΩÏö∞: "vector_search('ÌÅ¥ÎùºÏö∞Îìú Î≥¥Ïïà', 3)"

Ï§ëÏöî: Í∞ÑÍ≤∞Ìïú JSON ÏùëÎãµÏùÑ Ï†úÍ≥µÌïòÏÑ∏Ïöî. ÏÑ§Î™ÖÏùÑ Í∞ÑÎã®ÌïòÍ≤å Ïú†ÏßÄÌïòÏÑ∏Ïöî.

Îã§Ïùå JSON ÌòïÏãùÏúºÎ°ú ÏùëÎãµÌï¥Ï£ºÏÑ∏Ïöî:
{{
    "action_executed": "ÏàòÌñâÌïú ÏûëÏóÖÏùò Í∞ÑÎã®Ìïú ÏÑ§Î™Ö",
    "result": "ÏÑ±Ï∑®Ìïú ÎÇ¥Ïö©Ïùò Í∞ÑÎã®Ìïú ÏöîÏïΩ",
    "status": "SUCCESS|FAILED|PARTIAL",
    "data": {{}},
    "next_steps": ["Îã§Ïùå ÏûëÏóÖ"],
    "notes": "Ï£ºÏöî Í¥ÄÏ∞∞ÏÇ¨Ìï≠",
    "tools_used": ["ÏÇ¨Ïö©Ìïú ÎèÑÍµ¨Îì§"]
}}

ÏùëÎãµÏùÑ Í∞ÑÍ≤∞ÌïòÍ≤å Ïú†ÏßÄÌïòÍ≥† Ïú†Ìö®Ìïú JSON ÌòïÏãùÏùÑ Î≥¥Ïû•ÌïòÏÑ∏Ïöî.
"""
        
        response = self.llm.generate_response(execution_prompt, temperature=0.5)
        
        if response and response.strip():
            try:
                # Extract JSON from response
                if "```json" in response:
                    json_start = response.find("```json") + 7
                    json_end = response.find("```", json_start)
                    json_str = response[json_start:json_end].strip()
                else:
                    start = response.find("{")
                    end = response.rfind("}") + 1
                    json_str = response[start:end]
                
                # Check if we have valid JSON content
                if not json_str or json_str.strip() == "":
                    logger.warning("Empty JSON response received")
                    return self._create_default_execution_result(action, "Empty response from LLM", tools_used, tool_results)
                
                # Try to fix common JSON issues
                json_str = self._fix_json_string(json_str)
                
                result = json.loads(json_str)
                
                # Add tool usage information
                if tools_used:
                    result["tools_used"] = tools_used
                    result["tool_results"] = tool_results
                
                logger.info(f"Action executed: {result.get('action_executed', 'Unknown')}")
                if tools_used:
                    logger.info(f"Tools used: {', '.join(tools_used)}")
                
                return result
                
            except json.JSONDecodeError as e:
                logger.error(f"Failed to parse execution result: {e}")
                
                # Try to extract partial execution result
                partial_result = self._extract_partial_execution_result(response, action)
                if partial_result:
                    return partial_result
                
                return self._create_default_execution_result(action, f"JSON parsing error: {e}", tools_used, tool_results)
        else:
            logger.warning("No response received from LLM")
            return self._create_default_execution_result(action, "No response from LLM", tools_used, tool_results)
        
        return None
    
    def reflect_and_improve(self, task: str, plan: Dict, results: List[Dict]) -> Dict:
        """Reflect on the execution and suggest improvements"""
        
        reflection_prompt = f"""
ÎãπÏã†ÏùÄ ÏÑ±Ï∞∞ Î∞è Í∞úÏÑ† ÏóêÏù¥Ï†ÑÌä∏ÏûÖÎãàÎã§. ÏûëÏóÖ Ïã§ÌñâÏùÑ Î∂ÑÏÑùÌïòÍ≥† ÌÜµÏ∞∞ÏùÑ Ï†úÍ≥µÌïòÏÑ∏Ïöî.

ÏõêÎ≥∏ ÏûëÏóÖ: {task}
ÏõêÎ≥∏ Í≥ÑÌöç: {json.dumps(plan, indent=2)}
Ïã§Ìñâ Í≤∞Í≥º: {json.dumps(results, indent=2)}

Îã§Ïùå JSON ÌòïÏãùÏúºÎ°ú Î∂ÑÏÑùÏùÑ Ï†úÍ≥µÌï¥Ï£ºÏÑ∏Ïöî:
{{
    "success_rate": "ÏÑ±Í≥µÌïú ÏûëÏóÖÏùò ÎπÑÏú®",
    "key_insights": ["Ïã§ÌñâÏóê ÎåÄÌïú Ï§ëÏöîÌïú Í¥ÄÏ∞∞ÏÇ¨Ìï≠Îì§"],
    "improvements": ["Í≥ÑÌöçÏùÑ Í∞úÏÑ†Ìï† Ïàò ÏûàÎäî Î∞©Î≤ïÎì§"],
    "lessons_learned": ["Ïù¥Î≤à Ïã§ÌñâÏóêÏÑú Î∞∞Ïö¥ Í≤ÉÎì§"],
    "recommendations": ["Ìñ•ÌõÑ Ïú†ÏÇ¨Ìïú ÏûëÏóÖÏóê ÎåÄÌïú Íµ¨Ï≤¥Ï†ÅÏù∏ Í∂åÏû•ÏÇ¨Ìï≠Îì§"]
}}
"""
        
        response = self.llm.generate_response(reflection_prompt, temperature=0.4)
        
        if response and response.strip():
            try:
                # Extract JSON from response
                if "```json" in response:
                    json_start = response.find("```json") + 7
                    json_end = response.find("```", json_start)
                    json_str = response[json_start:json_end].strip()
                else:
                    start = response.find("{")
                    end = response.rfind("}") + 1
                    json_str = response[start:end]
                
                # Check if we have valid JSON content
                if not json_str or json_str.strip() == "":
                    logger.warning("Empty reflection response received")
                    return self._create_default_reflection()
                
                # Try to fix common JSON issues
                json_str = self._fix_json_string(json_str)
                
                reflection = json.loads(json_str)
                logger.info("Reflection and improvement analysis completed")
                return reflection
                
            except json.JSONDecodeError as e:
                logger.error(f"Failed to parse reflection: {e}")
                return self._create_default_reflection()
        else:
            logger.warning("No reflection response received from LLM")
            return self._create_default_reflection()
    
    def run_reasoning_acting_cycle(self, task: str, context: str = "") -> Dict:
        """Complete reasoning + acting cycle"""
        
        logger.info(f"Starting reasoning + acting cycle for task: {task}")
        
        # Step 1: Reason and Plan
        logger.info("Step 1: Reasoning and Planning...")
        plan = self.reason_and_plan(task, context)
        
        if not plan:
            logger.error("Failed to generate plan")
            return {"status": "FAILED", "error": "Plan generation failed"}
        
        logger.info(f"Generated plan with {len(plan.get('plan', []))} steps")
        
        # Step 2: Execute Actions
        logger.info("Step 2: Executing Actions...")
        results = []
        
        for step in plan.get('plan', []):
            action = step.get('action', 'Unknown action')
            logger.info(f"Executing step {step.get('step', '?')}: {action}")
            
            result = self.execute_action(action, {
                "step": step,
                "overall_plan": plan,
                "previous_results": results
            })
            
            results.append(result)
            
            if result and result.get('status') == 'FAILED':
                logger.warning(f"Action failed: {action}")
                break
        
        # Step 3: Reflect and Improve
        logger.info("Step 3: Reflecting and Improving...")
        reflection = self.reflect_and_improve(task, plan, results)
        
        # Compile final report
        final_report = {
            "task": task,
            "context": context,
            "plan": plan,
            "execution_results": results,
            "reflection": reflection,
            "status": "COMPLETED" if results else "FAILED"
        }
        
        logger.info("Reasoning + acting cycle completed")
        return final_report

def main():
    """Example usage of the reasoning + acting agent"""
    
    # Initialize the reasoning actor
    actor = ReasoningActor()
    
    # Example task: Analyze workshop data and provide insights
    task = """
    LiveLabs Ïä§ÌÅ¨ÎûòÌïë ÌîÑÎ°úÏ†ùÌä∏Ïùò ÏõåÌÅ¨ÏÉµ ÌÖçÏä§Ìä∏Î•º Î∂ÑÏÑùÌïòÍ≥† Îã§ÏùåÏùÑ Ï†úÍ≥µÌïòÏÑ∏Ïöî:
    1. Í∞ÄÏû• ÏùºÎ∞òÏ†ÅÏù∏ Ï£ºÏ†úÏôÄ ÌÖåÎßàÏùò ÏöîÏïΩ
    2. Ïò§ÎûòÎêòÏóàÍ±∞ÎÇò ÏóÖÎç∞Ïù¥Ìä∏Í∞Ä ÌïÑÏöîÌïú ÏõåÌÅ¨ÏÉµ ÏãùÎ≥Ñ
    3. ÏΩòÌÖêÏ∏† Í∞úÏÑ†ÏùÑ ÏúÑÌï¥ Ïö∞ÏÑ†ÏàúÏúÑÎ•º Ï†ïÌï¥Ïïº Ìï† ÏõåÌÅ¨ÏÉµÏóê ÎåÄÌïú Í∂åÏû•ÏÇ¨Ìï≠
    4. ÌòÑÏû¨ Ìä∏Î†åÎìúÎ•º Í∏∞Î∞òÏúºÎ°ú Ìïú ÏÉàÎ°úÏö¥ ÏõåÌÅ¨ÏÉµ Ï£ºÏ†ú Ï†úÏïà
    """
    
    context = """
    Oracle LiveLabsÏóêÏÑú ÏõåÌÅ¨ÏÉµ ÌÖçÏä§Ìä∏Î•º Ïä§ÌÅ¨ÎûòÌïëÌïòÏó¨ MongoDBÏóê Ï†ÄÏû•ÌñàÏäµÎãàÎã§.
    Îç∞Ïù¥ÌÑ∞ÏóêÎäî ÏõåÌÅ¨ÏÉµ Ï†úÎ™©, ÏÑ§Î™Ö, ÏΩòÌÖêÏ∏† Î∞è Î©îÌÉÄÎç∞Ïù¥ÌÑ∞Í∞Ä Ìè¨Ìï®ÎêòÏñ¥ ÏûàÏäµÎãàÎã§.
    ÏõåÌÅ¨ÏÉµ Ï†úÍ≥µÏùò ÌíàÏßàÍ≥º Í¥ÄÎ†®ÏÑ±ÏùÑ Í∞úÏÑ†ÌïòÍ≥† Ïã∂ÏäµÎãàÎã§.
    """
    
    # Run the reasoning + acting cycle
    print("üöÄ Oracle GenAIÎ•º ÏÇ¨Ïö©Ìïú Ï∂îÎ°† + Ïã§Ìñâ ÏòàÏ†ú ÏãúÏûë")
    print("=" * 60)
    
    try:
        result = actor.run_reasoning_acting_cycle(task, context)
        
        # Display results
        print("\nüìã ÏµúÏ¢Ö Î≥¥Í≥†ÏÑú")
        print("=" * 60)
        print(f"ÏûëÏóÖ: {result['task']}")
        print(f"ÏÉÅÌÉú: {result['status']}")
        
        if result and result.get('plan'):
            print(f"\nüìù ÏÉùÏÑ±Îêú Í≥ÑÌöç:")
            print(f"Ï∂îÎ°†: {result['plan'].get('reasoning', 'N/A')}")
            print(f"Îã®Í≥Ñ: {len(result['plan'].get('plan', []))}")
        
        if result and result.get('execution_results'):
            print(f"\n‚ö° Ïã§Ìñâ Í≤∞Í≥º:")
            for i, res in enumerate(result['execution_results'], 1):
                if res:  # Check if result is not None
                    status = res.get('status', 'Ïïå Ïàò ÏóÜÏùå')
                    action = res.get('action_executed', 'Ïïå Ïàò ÏóÜÏùå')
                    tools = res.get('tools_used', [])
                    
                    print(f"  Îã®Í≥Ñ {i}: {action} - {status}")
                    if tools:
                        print(f"    ÏÇ¨Ïö©Îêú ÎèÑÍµ¨: {', '.join(tools)}")
                        if 'tool_results' in res:
                            for tool_name, tool_result in res['tool_results'].items():
                                if tool_result.get('count', 0) > 0:
                                    print(f"    {tool_name}: {tool_result['count']}Í∞ú Í≤∞Í≥º")
                else:
                    print(f"  Îã®Í≥Ñ {i}: Í≤∞Í≥º ÏóÜÏùå")
        
        if result and result.get('reflection'):
            print(f"\nü§î ÏÑ±Ï∞∞ Î∞è Í∞úÏÑ†ÏÇ¨Ìï≠:")
            reflection = result['reflection']
            if reflection:  # Check if reflection is not None
                print(f"  ÏÑ±Í≥µÎ•†: {reflection.get('success_rate', 'N/A')}")
                print(f"  Ï£ºÏöî ÌÜµÏ∞∞: {', '.join(reflection.get('key_insights', []))}")
                print(f"  Í∂åÏû•ÏÇ¨Ìï≠: {', '.join(reflection.get('recommendations', []))}")
            else:
                print("  ÏÑ±Ï∞∞ Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå")
        
        # Save detailed report
        with open('reasoning_acting_report.json', 'w') as f:
            json.dump(result, f, indent=2)
        print(f"\nüíæ ÏÉÅÏÑ∏ Î≥¥Í≥†ÏÑúÍ∞Ä Ï†ÄÏû•Îê®: reasoning_acting_report.json")
        
    except Exception as e:
        logger.error(f"Ï∂îÎ°† + Ïã§Ìñâ ÏÇ¨Ïù¥ÌÅ¥ÏóêÏÑú Ïò§Î•ò Î∞úÏÉù: {e}")
        print(f"‚ùå Ïò§Î•ò: {e}")

if __name__ == "__main__":
    main() 